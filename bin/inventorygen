#!/usr/bin/env python
import argparse
import datetime
import os
import re
import sys
import logging

import yaml
from utils.inventory import Inventory, PaperInfo


logger = logging.getLogger(__name__)

DATE_FORMATS = [
    "%Y-%m-%d",
    "%Y_%m_%d",
    "%Y"
]


def configure_logging():
    handlers = []
    handlers.append(logging.StreamHandler(sys.stdout))
    handlers.append(logging.FileHandler('log.inventorygen', 'w'))
    logging.basicConfig(handlers=handlers, level=logging.WARNING,
                        style='{', format="{asctime} | {levelname} | {name} | {module} | {message}")


def get_paper_name(data_dir: str):
    return os.path.basename(data_dir)


def get_year_conf(date: datetime.date, conf: dict):
    if date is None:
        return conf['default']
    for year_conf in conf['yearconf']:
        if date >= year_conf['from'] and date <= year_conf['to']:
            return year_conf
    return conf['default']


def is_tif(filename: str, use_extension: bool = True):
    if use_extension:
        return re.match(r".*\.tif", filename) is not None
    else:
        with open(filename, 'rb') as f:
            r = f.read(4)
            return r == b'\x49\x49\x2A\x00' or r == b'\x4D\x4D\x00\x2A'


def contains_tif_files(filenames: list):
    count = 0
    for filename in filenames:
        if is_tif(filename):
            count += 1
    return count


def parse_to_date(repr: str):
    for date_format in DATE_FORMATS:
        try:
            doc_date = datetime.datetime.strptime(repr, date_format).date()
        except ValueError:
            pass
        else:
            return doc_date


def extract_date(filename: str):
    filename = filename[:filename.rfind('.')]  # remove file extension
    # remove any non-digit char at the beginning of the filename
    for i, c in zip(range(len(filename)), filename):
        if c.isdigit():
            filename = filename[i:]
            break

    digits_sequences = list()
    current_digits_seq = str()
    for char in filename:
        if char.isdigit():
            current_digits_seq += char
        elif current_digits_seq:
            digits_sequences.append(current_digits_seq)
            current_digits_seq = str()
    if current_digits_seq:
        digits_sequences.append(current_digits_seq)

    doc_date = parse_to_date(filename)

    if doc_date:
        return doc_date

    date_join = "-".join(digits_sequences[:min(3, len(digits_sequences))])
    doc_date = parse_to_date(date_join)
    if doc_date:
        return doc_date

    doc_date = parse_to_date(digits_sequences[0])
    if doc_date:
        return doc_date
    return None


def prepare_paperInfo(config, doc_date:  datetime.date, paper_name: str, tif_count: int):
    year_conf = get_year_conf(doc_date, config)
    return PaperInfo(type=year_conf['type'], paperID=paper_name,
                     callNumber=year_conf['callNumber'],
                     title=year_conf['title'],
                     titleCollection=year_conf['titleCollection'],
                     subTitle=year_conf['subTitle'],
                     printer=year_conf['printer'],
                     publisher=year_conf['publisher'],
                     day=doc_date.strftime("%d") if doc_date else None,
                     month=doc_date.strftime("%m") if doc_date else None,
                     year=doc_date.strftime("%Y") if doc_date else None,
                     pages=f"{tif_count}",
                     languages=year_conf['languages'])


def find_documents_in_dir(directory: str, files: list):
    doc_count = dict()
    for file in files:
        file_date = extract_date(file)
        if file_date is None:
            logger.warning(f"Couldn't parse date in file {file}")
        elif file_date not in doc_count:
            tmp = list()
            doc_count[file_date] = tmp
        doc_count[file_date].append(file)
    return doc_count


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    required = parser.add_argument_group("required arguments")
    required.add_argument("-c", "--config-file", type=str, required=True,
                        help="Specify configuration file.")
    parser.add_argument("-d", "--data-path",
                          type=str, default=None,
                          help="Directory containing data to parse. Overrides datapath set in the config file")
    parser.add_argument("-p", "--project-name", type=str, default=None,
                        help="Project name, Overrides project set in the config file")
    parser.add_argument("-o", "--output-file",
                          type=str, default=None,
                          help="Output inventory file")
    args = parser.parse_args()

    configure_logging()

    if not os.path.isfile(args.config_file):
        logger.critical(f"Specified config file {args.config_file} doesn't exist. Aborting.")
        sys.exit(1)
    with open(args.config_file) as f:
        config = yaml.safe_load(f)
    if args.data_path:
        config['datapath'] = args.data_path
    if args.project_name:
        config['project'] = args.project_name
    if args.output_file:
        config['outputfile'] = args.output_file

    data_dir = config['datapath']
    if not os.path.isdir(data_dir):
        logger.critical(f"Specified data directory {data_dir} doesn't exist. Aborting.")
        sys.exit(1)
    paper_name = get_paper_name(data_dir)
    inventory = Inventory(config['project'])
    for directory, subdirs, files in os.walk(data_dir):
        tif_count = contains_tif_files(files)
        logger.debug(f"Found tif files in {directory}")
        if tif_count and not subdirs:
            documents = find_documents_in_dir(directory, files)
            for document, docfiles in documents.items():
                paperInfo = prepare_paperInfo(config, document, paper_name, len(docfiles))
                doc_id = f"{paper_name}_{document}"
                doc_id = doc_id.replace(" ", "_")
                inventory.add_document(doc_id, paperInfo)
    if len(inventory):
        inventory.write(config['outputfile'])
